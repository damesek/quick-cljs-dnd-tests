shadow$provide.module$node_modules$$dnd_kit$core$dist$core_cjs_development=function(global,require,module,exports){function noop(..._args){}function getInitialState(){return{draggable:{active:null,initialCoordinates:{x:0,y:0},nodes:{},translate:{x:0,y:0}},droppable:{containers:new DroppableContainersMap}}}function reducer(state,action){switch(action.type){case Action.DragStart:return Object.assign({},state,{draggable:Object.assign({},state.draggable,{initialCoordinates:action.initialCoordinates,active:action.active})});
case Action.DragMove:return state.draggable.active?Object.assign({},state,{draggable:Object.assign({},state.draggable,{translate:{x:action.coordinates.x-state.draggable.initialCoordinates.x,y:action.coordinates.y-state.draggable.initialCoordinates.y}})}):state;case Action.DragEnd:case Action.DragCancel:return Object.assign({},state,{draggable:Object.assign({},state.draggable,{active:null,initialCoordinates:{x:0,y:0},translate:{x:0,y:0}})});case Action.RegisterDroppable:({element:action}=action);var {id:id$jscomp$1}=
action;const containers=new DroppableContainersMap(state.droppable.containers);containers.set(id$jscomp$1,action);return Object.assign({},state,{droppable:Object.assign({},state.droppable,{containers})});case Action.SetDroppableDisabled:const {id,key,disabled}=action;action=state.droppable.containers.get(id);if(!action||key!==action.key)return state;id$jscomp$1=new DroppableContainersMap(state.droppable.containers);id$jscomp$1.set(id,Object.assign({},action,{disabled}));return Object.assign({},state,
{droppable:Object.assign({},state.droppable,{containers:id$jscomp$1})});case Action.UnregisterDroppable:const {id:id$jscomp$0,key:key$jscomp$0}=action;action=state.droppable.containers.get(id$jscomp$0);if(!action||key$jscomp$0!==action.key)return state;action=new DroppableContainersMap(state.droppable.containers);action.delete(id$jscomp$0);return Object.assign({},state,{droppable:Object.assign({},state.droppable,{containers:action})});default:return state}}function useDndMonitor($jscomp$destructuring$var49){var {onDragStart,
onDragMove,onDragOver,onDragEnd,onDragCancel}=$jscomp$destructuring$var49;const monitorState=React.useContext(DndMonitorContext),previousMonitorState=React.useRef(monitorState);React.useEffect(()=>{if(monitorState!==previousMonitorState.current){const {type,event}=monitorState;switch(type){case Action.DragStart:null==onDragStart?void 0:onDragStart(event);break;case Action.DragMove:null==onDragMove?void 0:onDragMove(event);break;case Action.DragOver:null==onDragOver?void 0:onDragOver(event);break;
case Action.DragCancel:null==onDragCancel?void 0:onDragCancel(event);break;case Action.DragEnd:null==onDragEnd?void 0:onDragEnd(event)}previousMonitorState.current=monitorState}},[monitorState,onDragStart,onDragMove,onDragOver,onDragEnd,onDragCancel])}function Accessibility($jscomp$destructuring$var50){var {announcements=defaultAnnouncements,hiddenTextDescribedById,screenReaderInstructions}=$jscomp$destructuring$var50;const {announce,announcement}=accessibility.useAnnouncement();$jscomp$destructuring$var50=
utilities.useUniqueId("DndLiveRegion");const [mounted,setMounted]=React.useState(!1);React.useEffect(()=>{setMounted(!0)},[]);useDndMonitor(React.useMemo(()=>({onDragStart($jscomp$destructuring$var51){({active:$jscomp$destructuring$var51}=$jscomp$destructuring$var51);announce(announcements.onDragStart($jscomp$destructuring$var51.id))},onDragMove($jscomp$destructuring$var52){var {active,over}=$jscomp$destructuring$var52;announcements.onDragMove&&announce(announcements.onDragMove(active.id,null==over?
void 0:over.id))},onDragOver($jscomp$destructuring$var53){var {active,over}=$jscomp$destructuring$var53;announce(announcements.onDragOver(active.id,null==over?void 0:over.id))},onDragEnd($jscomp$destructuring$var54){var {active,over}=$jscomp$destructuring$var54;announce(announcements.onDragEnd(active.id,null==over?void 0:over.id))},onDragCancel($jscomp$destructuring$var55){({active:$jscomp$destructuring$var55}=$jscomp$destructuring$var55);announce(announcements.onDragCancel($jscomp$destructuring$var55.id))}}),
[announce,announcements]));return mounted?reactDom.createPortal(React__default.createElement(React__default.Fragment,null,React__default.createElement(accessibility.HiddenText,{id:hiddenTextDescribedById,value:screenReaderInstructions.draggable}),React__default.createElement(accessibility.LiveRegion,{id:$jscomp$destructuring$var50,announcement})),document.body):null}function distanceBetween(p1,p2){return Math.sqrt(Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2))}function getRelativeTransformOrigin(event,
rect){return(event=utilities.getEventCoordinates(event))?`${(event.x-rect.left)/rect.width*100}% ${(event.y-rect.top)/rect.height*100}%`:"0 0"}function sortCollisionsAsc($jscomp$destructuring$var56,$jscomp$destructuring$var57){({data:{value:$jscomp$destructuring$var56}}=$jscomp$destructuring$var56);({data:{value:$jscomp$destructuring$var57}}=$jscomp$destructuring$var57);return $jscomp$destructuring$var56-$jscomp$destructuring$var57}function sortCollisionsDesc($jscomp$destructuring$var58,$jscomp$destructuring$var59){({data:{value:$jscomp$destructuring$var58}}=
$jscomp$destructuring$var58);({data:{value:$jscomp$destructuring$var59}}=$jscomp$destructuring$var59);return $jscomp$destructuring$var59-$jscomp$destructuring$var58}function cornersOfRectangle($jscomp$destructuring$var60){var {left,top,height,width}=$jscomp$destructuring$var60;return[{x:left,y:top},{x:left+width,y:top},{x:left,y:top+height},{x:left+width,y:top+height}]}function getFirstCollision(collisions,property){if(!collisions||0===collisions.length)return null;[collisions]=collisions;return property?
collisions[property]:collisions}function centerOfRectangle(rect,left,top){left=void 0===left?rect.left:left;top=void 0===top?rect.top:top;return{x:left+.5*rect.width,y:top+.5*rect.height}}function isPointWithinRect(point,rect){const {top,left,bottom,right}=rect;return top<=point.y&&point.y<=bottom&&left<=point.x&&point.x<=right}function adjustScale(transform,rect1,rect2){return Object.assign({},transform,{scaleX:rect1&&rect2?rect1.width/rect2.width:1,scaleY:rect1&&rect2?rect1.height/rect2.height:
1})}function getClientRect(element,options){options=void 0===options?defaultOptions:options;var rect=element.getBoundingClientRect();if(options.ignoreTransform){({getComputedStyle:options}=utilities.getWindow(element));const {transform,transformOrigin}=options(element);if(transform)a:{element=rect;rect=transform;options=transformOrigin;if(rect.startsWith("matrix3d(")){var ta=rect.slice(9,-1).split(/, /);var sx=+ta[0];rect=+ta[5];var dx=+ta[12];ta=+ta[13]}else if(rect.startsWith("matrix("))ta=rect.slice(7,
-1).split(/, /),sx=+ta[0],rect=+ta[3],dx=+ta[4],ta=+ta[5];else{rect=element;break a}dx=element.left-dx-(1-sx)*parseFloat(options);options=element.top-ta-(1-rect)*parseFloat(options.slice(options.indexOf(" ")+1));sx=sx?element.width/sx:element.width;element=rect?element.height/rect:element.height;rect={width:sx,height:element,top:options,right:dx+sx,bottom:options+element,left:dx}}}const {top,left,width,height,bottom,right}=rect;return{top,left,width,height,bottom,right}}function getTransformAgnosticClientRect(element){return getClientRect(element,
{ignoreTransform:!0})}function isScrollable(element,computedStyle){computedStyle=void 0===computedStyle?utilities.getWindow(element).getComputedStyle(element):computedStyle;const overflowRegex=/(auto|scroll|overlay)/;return null!=["overflow","overflowX","overflowY"].find(property=>{property=computedStyle[property];return"string"===typeof property?overflowRegex.test(property):!1})}function getScrollableAncestors(element){function findScrollableAncestors(node){if(!node)return scrollParents;if(utilities.isDocument(node)&&
null!=node.scrollingElement&&!scrollParents.includes(node.scrollingElement))return scrollParents.push(node.scrollingElement),scrollParents;if(!utilities.isHTMLElement(node)||utilities.isSVGElement(node)||scrollParents.includes(node))return scrollParents;var {getComputedStyle}=utilities.getWindow(node);getComputedStyle=getComputedStyle(node);node!==element&&isScrollable(node,getComputedStyle)&&scrollParents.push(node);getComputedStyle=void 0===getComputedStyle?utilities.getWindow(node).getComputedStyle(node):
getComputedStyle;return"fixed"===getComputedStyle.position?scrollParents:findScrollableAncestors(node.parentNode)}const scrollParents=[];return element?findScrollableAncestors(element):scrollParents}function getScrollableElement(element){return utilities.canUseDOM&&element?utilities.isWindow(element)?element:utilities.isNode(element)?utilities.isDocument(element)||element===utilities.getOwnerDocument(element).scrollingElement?window:utilities.isHTMLElement(element)?element:null:null:null}function getScrollXCoordinate(element){return utilities.isWindow(element)?
element.scrollX:element.scrollLeft}function getScrollYCoordinate(element){return utilities.isWindow(element)?element.scrollY:element.scrollTop}function getScrollCoordinates(element){return{x:getScrollXCoordinate(element),y:getScrollYCoordinate(element)}}function getScrollPosition(scrollingContainer){const minScroll={x:0,y:0},maxScroll={x:scrollingContainer.scrollWidth-scrollingContainer.clientWidth,y:scrollingContainer.scrollHeight-scrollingContainer.clientHeight};return{isTop:scrollingContainer.scrollTop<=
minScroll.y,isLeft:scrollingContainer.scrollLeft<=minScroll.x,isBottom:scrollingContainer.scrollTop>=maxScroll.y,isRight:scrollingContainer.scrollLeft>=maxScroll.x,maxScroll,minScroll}}function getScrollOffsets(scrollableAncestors){return scrollableAncestors.reduce((acc,node)=>utilities.add(acc,getScrollCoordinates(node)),defaultCoordinates)}function useAutoScroller($jscomp$destructuring$var67){var {acceleration,activator=exports.AutoScrollActivator.Pointer,canScroll,draggingRect,enabled,interval=
5,order=exports.TraversalOrder.TreeOrder,pointerCoordinates,scrollableAncestors,scrollableAncestorRects,threshold}=$jscomp$destructuring$var67;const [setAutoScrollInterval,clearAutoScrollInterval]=utilities.useInterval(),scrollSpeed=React.useRef({x:1,y:1}),rect=React.useMemo(()=>{switch(activator){case exports.AutoScrollActivator.Pointer:return pointerCoordinates?{top:pointerCoordinates.y,bottom:pointerCoordinates.y,left:pointerCoordinates.x,right:pointerCoordinates.x}:null;case exports.AutoScrollActivator.DraggableRect:return draggingRect}return null},
[activator,draggingRect,pointerCoordinates]),scrollDirection=React.useRef(defaultCoordinates),scrollContainerRef=React.useRef(null),autoScroll=React.useCallback(()=>{const scrollContainer=scrollContainerRef.current;scrollContainer&&scrollContainer.scrollBy(scrollSpeed.current.x*scrollDirection.current.x,scrollSpeed.current.y*scrollDirection.current.y)},[]),sortedScrollableAncestors=React.useMemo(()=>order===exports.TraversalOrder.TreeOrder?[...scrollableAncestors].reverse():scrollableAncestors,[order,
scrollableAncestors]);React.useEffect(()=>{if(enabled&&scrollableAncestors.length&&rect){for(const scrollContainer of sortedScrollableAncestors){if(!1===(null==canScroll?void 0:canScroll(scrollContainer)))continue;var index=scrollableAncestors.indexOf(scrollContainer);index=scrollableAncestorRects[index];if(!index)continue;var scrollContainer$jscomp$0=scrollContainer,scrollContainerRect=index;index=acceleration;var thresholdPercentage=threshold,{top,left,right,bottom}=rect;index=void 0===index?10:
index;thresholdPercentage=void 0===thresholdPercentage?defaultThreshold:thresholdPercentage;const {clientHeight,clientWidth}=scrollContainer$jscomp$0;scrollContainerRect=utilities.canUseDOM&&scrollContainer$jscomp$0&&scrollContainer$jscomp$0===document.scrollingElement?{top:0,left:0,right:clientWidth,bottom:clientHeight,width:clientWidth,height:clientHeight}:scrollContainerRect;const {isTop,isBottom,isLeft,isRight}=getScrollPosition(scrollContainer$jscomp$0),direction={x:0,y:0},speed={x:0,y:0};scrollContainer$jscomp$0=
scrollContainerRect.height*thresholdPercentage.y;thresholdPercentage=scrollContainerRect.width*thresholdPercentage.x;!isTop&&top<=scrollContainerRect.top+scrollContainer$jscomp$0?(direction.y=Direction.Backward,speed.y=index*Math.abs((scrollContainerRect.top+scrollContainer$jscomp$0-top)/scrollContainer$jscomp$0)):!isBottom&&bottom>=scrollContainerRect.bottom-scrollContainer$jscomp$0&&(direction.y=Direction.Forward,speed.y=index*Math.abs((scrollContainerRect.bottom-scrollContainer$jscomp$0-bottom)/
scrollContainer$jscomp$0));!isRight&&right>=scrollContainerRect.right-thresholdPercentage?(direction.x=Direction.Forward,speed.x=index*Math.abs((scrollContainerRect.right-thresholdPercentage-right)/thresholdPercentage)):!isLeft&&left<=scrollContainerRect.left+thresholdPercentage&&(direction.x=Direction.Backward,speed.x=index*Math.abs((scrollContainerRect.left+thresholdPercentage-left)/thresholdPercentage));const {direction:direction$jscomp$0,speed:speed$jscomp$0}={direction,speed};if(0<speed$jscomp$0.x||
0<speed$jscomp$0.y){clearAutoScrollInterval();scrollContainerRef.current=scrollContainer;setAutoScrollInterval(autoScroll,interval);scrollSpeed.current=speed$jscomp$0;scrollDirection.current=direction$jscomp$0;return}}scrollSpeed.current={x:0,y:0};scrollDirection.current={x:0,y:0}}clearAutoScrollInterval()},[acceleration,autoScroll,canScroll,clearAutoScrollInterval,enabled,interval,JSON.stringify(rect),setAutoScrollInterval,scrollableAncestors,sortedScrollableAncestors,scrollableAncestorRects,JSON.stringify(threshold)])}
function useCachedNode(draggableNodes,id){const node=(draggableNodes=null!==id?draggableNodes[id]:void 0)?draggableNodes.node.current:null;return utilities.useLazyMemo(cachedNode=>{var _ref;return null===id?null:null!=(_ref=null!=node?node:cachedNode)?_ref:null},[node,id])}function useCombineActivators(sensors,getSyntheticHandler){return React.useMemo(()=>sensors.reduce((accumulator,sensor)=>{var {sensor:Sensor}=sensor;Sensor=Sensor.activators.map(activator=>({eventName:activator.eventName,handler:getSyntheticHandler(activator.handler,
sensor)}));return[...accumulator,...Sensor]},[]),[sensors,getSyntheticHandler])}function useDroppableMeasuring(containers,$jscomp$destructuring$var68){var {dragging,dependencies,config}=$jscomp$destructuring$var68;const [containerIdsScheduledForMeasurement,setContainerIdsScheduledForMeasurement]=React.useState(null),measuringScheduled=null!=containerIdsScheduledForMeasurement,{frequency,measure,strategy}=Object.assign({},defaultConfig,config),containersRef=React.useRef(containers),measureDroppableContainers=
React.useCallback(ids=>{ids=void 0===ids?[]:ids;return setContainerIdsScheduledForMeasurement(value=>value?value.concat(ids):ids)},[]),timeoutId=React.useRef(null),disabled=function(){switch(strategy){case exports.MeasuringStrategy.Always:return!1;case exports.MeasuringStrategy.BeforeDragging:return dragging;default:return!dragging}}();$jscomp$destructuring$var68=utilities.useLazyMemo(previousValue=>{if(disabled&&!dragging)return defaultValue$jscomp$0;if(!previousValue||previousValue===defaultValue$jscomp$0||
containersRef.current!==containers||null!=containerIdsScheduledForMeasurement){previousValue=new Map;for(let container of containers)if(container)if(containerIdsScheduledForMeasurement&&0<containerIdsScheduledForMeasurement.length&&!containerIdsScheduledForMeasurement.includes(container.id)&&container.rect.current)previousValue.set(container.id,container.rect.current);else{var node=container.node.current;node=node?new Rect(measure(node),node):null;(container.rect.current=node)&&previousValue.set(container.id,
node)}return previousValue}return previousValue},[containers,containerIdsScheduledForMeasurement,dragging,disabled,measure]);React.useEffect(()=>{containersRef.current=containers},[containers]);React.useEffect(()=>{disabled||requestAnimationFrame(()=>measureDroppableContainers())},[dragging,disabled]);React.useEffect(()=>{measuringScheduled&&setContainerIdsScheduledForMeasurement(null)},[measuringScheduled]);React.useEffect(()=>{disabled||"number"!==typeof frequency||null!==timeoutId.current||(timeoutId.current=
setTimeout(()=>{measureDroppableContainers();timeoutId.current=null},frequency))},[frequency,disabled,measureDroppableContainers,...dependencies]);return{droppableRects:$jscomp$destructuring$var68,measureDroppableContainers,measuringScheduled}}function useResizeObserver($jscomp$destructuring$var69){var {onResize,disabled}=$jscomp$destructuring$var69;const resizeObserver=React.useMemo(()=>{if(!disabled&&"undefined"!==typeof window&&"undefined"!==typeof window.ResizeObserver){var {ResizeObserver}=window;
return new ResizeObserver(onResize)}},[disabled,onResize]);React.useEffect(()=>()=>null==resizeObserver?void 0:resizeObserver.disconnect(),[resizeObserver]);return resizeObserver}function useScrollOffsets(elements){const [scrollCoordinates,setScrollCoordinates]=React.useState(null),prevElements=React.useRef(elements),handleScroll=React.useCallback(event=>{const scrollingElement=getScrollableElement(event.target);scrollingElement&&setScrollCoordinates(scrollCoordinates=>{if(!scrollCoordinates)return null;
scrollCoordinates.set(scrollingElement,getScrollCoordinates(scrollingElement));return new Map(scrollCoordinates)})},[]);React.useEffect(()=>{function cleanup(elements){elements.forEach(element=>{element=getScrollableElement(element);null==element?void 0:element.removeEventListener("scroll",handleScroll)})}const previousElements=prevElements.current;if(elements!==previousElements){cleanup(previousElements);const entries=elements.map(element=>(element=getScrollableElement(element))?(element.addEventListener("scroll",
handleScroll,{passive:!0}),[element,getScrollCoordinates(element)]):null).filter(entry=>null!=entry);setScrollCoordinates(entries.length?new Map(entries):null);prevElements.current=elements}return()=>{cleanup(elements);cleanup(previousElements)}},[handleScroll,elements]);return React.useMemo(()=>elements.length?scrollCoordinates?Array.from(scrollCoordinates.values()).reduce((acc,coordinates)=>utilities.add(acc,coordinates),defaultCoordinates):getScrollOffsets(elements):defaultCoordinates,[elements,
scrollCoordinates])}function useScrollableAncestors(node){const previousNode=React.useRef(node),ancestors=utilities.useLazyMemo(previousValue=>node?previousValue&&node&&previousNode.current&&node.parentNode===previousNode.current.parentNode?previousValue:getScrollableAncestors(node):defaultValue$1,[node]);React.useEffect(()=>{previousNode.current=node},[node]);return ancestors}function useSensorSetup(sensors){React.useEffect(()=>{if(utilities.canUseDOM){var teardownFns=sensors.map($jscomp$destructuring$var70=>
{({sensor:$jscomp$destructuring$var70}=$jscomp$destructuring$var70);return null==$jscomp$destructuring$var70.setup?void 0:$jscomp$destructuring$var70.setup()});return()=>{for(const teardown of teardownFns)null==teardown?void 0:teardown()}}},sensors.map($jscomp$destructuring$var71=>{({sensor:$jscomp$destructuring$var71}=$jscomp$destructuring$var71);return $jscomp$destructuring$var71}))}function useSyntheticListeners(listeners,id){return React.useMemo(()=>listeners.reduce((acc,$jscomp$destructuring$var72)=>
{var {eventName,handler}=$jscomp$destructuring$var72;acc[eventName]=event=>{handler(event,id)};return acc},{}),[listeners,id])}function useRect(element,getRect,forceRecompute){const previousElement=React.useRef(element);return utilities.useLazyMemo(previousValue=>element?forceRecompute||!previousValue&&element||element!==previousElement.current?utilities.isHTMLElement(element)&&null==element.parentNode?null:new Rect(getRect(element),element):null!=previousValue?previousValue:null:null,[element,forceRecompute,
getRect])}function useWindowRect(element){return React.useMemo(()=>{if(element){var JSCompiler_temp=element.innerWidth;const height=element.innerHeight;JSCompiler_temp={top:0,left:0,right:JSCompiler_temp,bottom:height,width:JSCompiler_temp,height}}else JSCompiler_temp=null;return JSCompiler_temp},[element])}function getMeasurableNode(node){if(!node)return null;if(1<node.children.length)return node;const firstChild=node.children[0];return utilities.isHTMLElement(firstChild)?firstChild:node}function useDragOverlayMeasuring($jscomp$destructuring$var73){var {measure=
getClientRect}=$jscomp$destructuring$var73;const [rect$jscomp$0,setRect]=React.useState(null);$jscomp$destructuring$var73=React.useCallback(entries=>{for(const $jscomp$destructuring$var74 of entries){const {target}=$jscomp$destructuring$var74;if(utilities.isHTMLElement(target)){setRect(rect=>{const newRect=measure(target);return rect?Object.assign({},rect,{width:newRect.width,height:newRect.height}):newRect});break}}},[measure]);const resizeObserver=useResizeObserver({onResize:$jscomp$destructuring$var73});
$jscomp$destructuring$var73=React.useCallback(element=>{element=getMeasurableNode(element);null==resizeObserver?void 0:resizeObserver.disconnect();element&&(null==resizeObserver?void 0:resizeObserver.observe(element));setRect(element?measure(element):null)},[measure,resizeObserver]);const [nodeRef,setRef]=utilities.useNodeRef($jscomp$destructuring$var73);return React.useMemo(()=>({nodeRef,rect:rect$jscomp$0,setRef}),[rect$jscomp$0,nodeRef,setRef])}function hasExceededDistance(delta,measurement){const dx=
Math.abs(delta.x);delta=Math.abs(delta.y);return"number"===typeof measurement?Math.sqrt(Math.pow(dx,2)+Math.pow(delta,2))>measurement:"x"in measurement&&"y"in measurement?dx>measurement.x&&delta>measurement.y:"x"in measurement?dx>measurement.x:"y"in measurement?delta>measurement.y:!1}function preventDefault(event){event.preventDefault()}function stopPropagation(event){event.stopPropagation()}function applyModifiers(modifiers,$jscomp$destructuring$var83){var $jscomp$destructuring$var85=Object.assign({},
$jscomp$destructuring$var83);$jscomp$destructuring$var83=$jscomp$destructuring$var83.transform;var args=(delete $jscomp$destructuring$var85.transform,$jscomp$destructuring$var85);return(null==modifiers?0:modifiers.length)?modifiers.reduce((accumulator,modifier)=>modifier(Object.assign({},{transform:accumulator},args)),$jscomp$destructuring$var83):$jscomp$destructuring$var83}function useDndContext(){return React.useContext(PublicContext)}function useDropAnimation($jscomp$destructuring$var92){var {animate,
adjustScale,activeId,draggableNodes,duration,dragSourceOpacity,easing,node,transform}=$jscomp$destructuring$var92;const [dropAnimationComplete,setDropAnimationComplete]=React.useState(!1);utilities.useIsomorphicLayoutEffect(()=>{var _draggableNodes$activ;if(animate&&activeId&&easing&&duration){var finalNode=null==(_draggableNodes$activ=draggableNodes[activeId])?void 0:_draggableNodes$activ.node.current;if(transform&&node&&finalNode&&null!==finalNode.parentNode&&(_draggableNodes$activ=getMeasurableNode(node))){const from=
_draggableNodes$activ.getBoundingClientRect(),to=getTransformAgnosticClientRect(finalNode);_draggableNodes$activ=from.left-to.left;var JSCompiler_object_inline_y_145=from.top-to.top;if(Math.abs(_draggableNodes$activ)||Math.abs(JSCompiler_object_inline_y_145)){_draggableNodes$activ=utilities.CSS.Transform.toString(Object.assign({},{x:transform.x-_draggableNodes$activ,y:transform.y-JSCompiler_object_inline_y_145},{scaleX:adjustScale?to.width*transform.scaleX/from.width:1,scaleY:adjustScale?to.height*
transform.scaleY/from.height:1}));const originalOpacity=finalNode.style.opacity;null!=dragSourceOpacity&&(finalNode.style.opacity=`${dragSourceOpacity}`);node.animate([{transform:utilities.CSS.Transform.toString(transform)},{transform:_draggableNodes$activ}],{easing,duration}).onfinish=()=>{node.style.display="none";setDropAnimationComplete(!0);finalNode&&null!=dragSourceOpacity&&(finalNode.style.opacity=originalOpacity)};return}}setDropAnimationComplete(!0)}else animate&&setDropAnimationComplete(!0)},
[animate,activeId,adjustScale,draggableNodes,duration,easing,dragSourceOpacity,node,transform]);utilities.useIsomorphicLayoutEffect(()=>{dropAnimationComplete&&setDropAnimationComplete(!1)},[dropAnimationComplete]);return dropAnimationComplete}Object.defineProperty(exports,"__esModule",{value:!0});var React=require("module$node_modules$react$index"),React__default=React&&"object"===typeof React&&"default"in React?React["default"]:React,reactDom=require("module$node_modules$react_dom$index"),utilities=
require("module$node_modules$$dnd_kit$utilities$dist$index"),accessibility=require("module$node_modules$$dnd_kit$accessibility$dist$index");const screenReaderInstructions={draggable:"\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "},defaultAnnouncements={onDragStart(id){return`Picked up draggable item ${id}.`},onDragOver(id,overId){return overId?
`Draggable item ${id} was moved over droppable area ${overId}.`:`Draggable item ${id} is no longer over a droppable area.`},onDragEnd(id,overId){return overId?`Draggable item ${id} was dropped over droppable area ${overId}`:`Draggable item ${id} was dropped.`},onDragCancel(id){return`Dragging was cancelled. Draggable item ${id} was dropped.`}};var Action;(function(Action){Action.DragStart="dragStart";Action.DragMove="dragMove";Action.DragEnd="dragEnd";Action.DragCancel="dragCancel";Action.DragOver=
"dragOver";Action.RegisterDroppable="registerDroppable";Action.SetDroppableDisabled="setDroppableDisabled";Action.UnregisterDroppable="unregisterDroppable"})(Action||(Action={}));class DroppableContainersMap extends Map{get(id){var _super$get;return null!=id?null!=(_super$get=super.get(id))?_super$get:void 0:void 0}toArray(){return Array.from(this.values())}getEnabled(){return this.toArray().filter($jscomp$destructuring$var48=>{({disabled:$jscomp$destructuring$var48}=$jscomp$destructuring$var48);
return!$jscomp$destructuring$var48})}getNodeFor(id){var _this$get$node$curren,_this$get;return null!=(_this$get$node$curren=null==(_this$get=this.get(id))?void 0:_this$get.node.current)?_this$get$node$curren:void 0}}global={activatorEvent:null,active:null,activeNode:null,activeNodeRect:null,collisions:null,containerNodeRect:null,draggableNodes:{},droppableRects:new Map,droppableContainers:new DroppableContainersMap,over:null,dragOverlay:{nodeRef:{current:null},rect:null,setRef:noop},scrollableAncestors:[],
scrollableAncestorRects:[],measureDroppableContainers:noop,windowRect:null,measuringScheduled:!1};const defaultInternalContext={activatorEvent:null,activators:[],active:null,activeNodeRect:null,ariaDescribedById:{draggable:""},dispatch:noop,draggableNodes:{},over:null,measureDroppableContainers:noop},InternalContext=React.createContext(defaultInternalContext),PublicContext=React.createContext(global),DndMonitorContext=React.createContext({type:null,event:null}),defaultCoordinates=Object.freeze({x:0,
y:0}),rectIntersection=$jscomp$destructuring$var63=>{var {collisionRect,droppableContainers}=$jscomp$destructuring$var63;$jscomp$destructuring$var63=[];for(const droppableContainer of droppableContainers){const {id,rect:{current:rect}}=droppableContainer;if(rect){{var JSCompiler_inline_result=Math.max(collisionRect.top,rect.top);const left=Math.max(collisionRect.left,rect.left),right=Math.min(collisionRect.left+collisionRect.width,rect.left+rect.width),bottom=Math.min(collisionRect.top+collisionRect.height,
rect.top+rect.height);left<right&&JSCompiler_inline_result<bottom?(JSCompiler_inline_result=(right-left)*(bottom-JSCompiler_inline_result),JSCompiler_inline_result=Number((JSCompiler_inline_result/(collisionRect.width*collisionRect.height+rect.width*rect.height-JSCompiler_inline_result)).toFixed(4))):JSCompiler_inline_result=0}0<JSCompiler_inline_result&&$jscomp$destructuring$var63.push({id,data:{droppableContainer,value:JSCompiler_inline_result}})}}return $jscomp$destructuring$var63.sort(sortCollisionsDesc)},
getAdjustedRect=function(modifier){return function(rect,...adjustments){return adjustments.reduce((acc,adjustment)=>Object.assign({},acc,{top:acc.top+modifier*adjustment.y,bottom:acc.bottom+modifier*adjustment.y,left:acc.left+modifier*adjustment.x,right:acc.right+modifier*adjustment.x}),Object.assign({},rect))}}(1),defaultOptions={ignoreTransform:!1};var Direction;(function(Direction){Direction[Direction.Forward=1]="Forward";Direction[Direction.Backward=-1]="Backward"})(Direction||(Direction={}));
const defaultThreshold={x:.2,y:.2},properties=[["x",["left","right"],function(scrollableAncestors){return scrollableAncestors.reduce((acc,node)=>acc+getScrollXCoordinate(node),0)}],["y",["top","bottom"],function(scrollableAncestors){return scrollableAncestors.reduce((acc,node)=>acc+getScrollYCoordinate(node),0)}]];class Rect{constructor(rect,element){this.left=this.right=this.bottom=this.top=this.height=this.width=this.rect=void 0;const scrollableAncestors=getScrollableAncestors(element),scrollOffsets=
getScrollOffsets(scrollableAncestors);this.rect=Object.assign({},rect);this.width=rect.width;this.height=rect.height;for(const $jscomp$destructuring$var66 of properties){const [axis,keys,getScrollOffset]=$jscomp$destructuring$var66;for(const key of keys)Object.defineProperty(this,key,{get:()=>{const currentOffsets=getScrollOffset(scrollableAncestors);return this.rect[key]+(scrollOffsets[axis]-currentOffsets)},enumerable:!0})}Object.defineProperty(this,"rect",{enumerable:!1})}}(function(AutoScrollActivator){AutoScrollActivator[AutoScrollActivator.Pointer=
0]="Pointer";AutoScrollActivator[AutoScrollActivator.DraggableRect=1]="DraggableRect"})(exports.AutoScrollActivator||(exports.AutoScrollActivator={}));(function(TraversalOrder){TraversalOrder[TraversalOrder.TreeOrder=0]="TreeOrder";TraversalOrder[TraversalOrder.ReversedTreeOrder=1]="ReversedTreeOrder"})(exports.TraversalOrder||(exports.TraversalOrder={}));(function(MeasuringStrategy){MeasuringStrategy[MeasuringStrategy.Always=0]="Always";MeasuringStrategy[MeasuringStrategy.BeforeDragging=1]="BeforeDragging";
MeasuringStrategy[MeasuringStrategy.WhileDragging=2]="WhileDragging"})(exports.MeasuringStrategy||(exports.MeasuringStrategy={}));(exports.MeasuringFrequency||(exports.MeasuringFrequency={})).Optimized="optimized";const defaultValue$jscomp$0=new Map,defaultConfig={measure:getTransformAgnosticClientRect,strategy:exports.MeasuringStrategy.WhileDragging,frequency:exports.MeasuringFrequency.Optimized},defaultValue$1=[],useClientRect=function(getRect){return(element,forceRecompute)=>useRect(element,getRect,
forceRecompute)}(getTransformAgnosticClientRect),useClientRects=function(getRect){const defaultValue=[];return function(elements,forceRecompute){const previousElements=React.useRef(elements);return utilities.useLazyMemo(previousValue=>elements.length?forceRecompute||!previousValue&&elements.length||elements!==previousElements.current?elements.map(element=>new Rect(getRect(element),element)):null!=previousValue?previousValue:defaultValue:defaultValue,[elements,forceRecompute])}}(getTransformAgnosticClientRect);
class Listeners{constructor(target){this.target=void 0;this.listeners=[];this.removeAll=()=>{this.listeners.forEach(listener=>{var _this$target;return null==(_this$target=this.target)?void 0:_this$target.removeEventListener(...listener)})};this.target=target}add(eventName,handler,options){var _this$target2;null==(_this$target2=this.target)?void 0:_this$target2.addEventListener(eventName,handler,options);this.listeners.push([eventName,handler,options])}}var EventName;(function(EventName){EventName.Click=
"click";EventName.DragStart="dragstart";EventName.Keydown="keydown";EventName.ContextMenu="contextmenu";EventName.Resize="resize";EventName.SelectionChange="selectionchange";EventName.VisibilityChange="visibilitychange"})(EventName||(EventName={}));(function(KeyboardCode){KeyboardCode.Space="Space";KeyboardCode.Down="ArrowDown";KeyboardCode.Right="ArrowRight";KeyboardCode.Left="ArrowLeft";KeyboardCode.Up="ArrowUp";KeyboardCode.Esc="Escape";KeyboardCode.Enter="Enter"})(exports.KeyboardCode||(exports.KeyboardCode=
{}));const defaultKeyboardCodes={start:[exports.KeyboardCode.Space,exports.KeyboardCode.Enter],cancel:[exports.KeyboardCode.Esc],end:[exports.KeyboardCode.Space,exports.KeyboardCode.Enter]},defaultKeyboardCoordinateGetter=(event,$jscomp$destructuring$var75)=>{({currentCoordinates:$jscomp$destructuring$var75}=$jscomp$destructuring$var75);switch(event.code){case exports.KeyboardCode.Right:return Object.assign({},$jscomp$destructuring$var75,{x:$jscomp$destructuring$var75.x+25});case exports.KeyboardCode.Left:return Object.assign({},
$jscomp$destructuring$var75,{x:$jscomp$destructuring$var75.x-25});case exports.KeyboardCode.Down:return Object.assign({},$jscomp$destructuring$var75,{y:$jscomp$destructuring$var75.y+25});case exports.KeyboardCode.Up:return Object.assign({},$jscomp$destructuring$var75,{y:$jscomp$destructuring$var75.y-25})}};class KeyboardSensor{constructor(props){this.autoScrollEnabled=!1;this.coordinates=defaultCoordinates;this.windowListeners=this.listeners=void 0;const {event:{target}}=props;this.props=props;this.listeners=
new Listeners(utilities.getOwnerDocument(target));this.windowListeners=new Listeners(utilities.getWindow(target));this.handleKeyDown=this.handleKeyDown.bind(this);this.handleCancel=this.handleCancel.bind(this);this.attach()}attach(){this.handleStart();this.windowListeners.add(EventName.Resize,this.handleCancel);this.windowListeners.add(EventName.VisibilityChange,this.handleCancel);setTimeout(()=>this.listeners.add(EventName.Keydown,this.handleKeyDown))}handleStart(){const {activeNode,onStart}=this.props;
if(!activeNode.node.current)throw Error("Active draggable node is undefined");var activeNodeRect=getTransformAgnosticClientRect(activeNode.node.current);this.coordinates=activeNodeRect={x:activeNodeRect.left,y:activeNodeRect.top};onStart(activeNodeRect)}handleKeyDown(event){if(utilities.isKeyboardEvent(event)){const {coordinates}=this,{active,context,options}=this.props,{keyboardCodes=defaultKeyboardCodes,coordinateGetter=defaultKeyboardCoordinateGetter,scrollBehavior="smooth"}=options;var {code}=
event;if(keyboardCodes.end.includes(code))this.handleEnd(event);else if(keyboardCodes.cancel.includes(code))this.handleCancel(event);else if(code=coordinateGetter(event,{active,context:context.current,currentCoordinates:coordinates})){const scrollDelta={x:0,y:0};var {scrollableAncestors}=context.current;for(const scrollContainer of scrollableAncestors){scrollableAncestors=event.code;const coordinatesDelta=utilities.subtract(code,coordinates),{isTop,isRight,isLeft,isBottom,maxScroll,minScroll}=getScrollPosition(scrollContainer);
a:{var JSCompiler_inline_result=scrollContainer;if(JSCompiler_inline_result===document.scrollingElement){const {innerWidth,innerHeight}=window;JSCompiler_inline_result={top:0,left:0,right:innerWidth,bottom:innerHeight,width:innerWidth,height:innerHeight};break a}const {top,left,right,bottom}=JSCompiler_inline_result.getBoundingClientRect();JSCompiler_inline_result={top,left,right,bottom,width:JSCompiler_inline_result.clientWidth,height:JSCompiler_inline_result.clientHeight}}var scrollElementRect=
JSCompiler_inline_result;JSCompiler_inline_result=Math.min(scrollableAncestors===exports.KeyboardCode.Right?scrollElementRect.right-scrollElementRect.width/2:scrollElementRect.right,Math.max(scrollableAncestors===exports.KeyboardCode.Right?scrollElementRect.left:scrollElementRect.left+scrollElementRect.width/2,code.x));scrollElementRect=Math.min(scrollableAncestors===exports.KeyboardCode.Down?scrollElementRect.bottom-scrollElementRect.height/2:scrollElementRect.bottom,Math.max(scrollableAncestors===
exports.KeyboardCode.Down?scrollElementRect.top:scrollElementRect.top+scrollElementRect.height/2,code.y));const canScrollY=scrollableAncestors===exports.KeyboardCode.Down&&!isBottom||scrollableAncestors===exports.KeyboardCode.Up&&!isTop;if((scrollableAncestors===exports.KeyboardCode.Right&&!isRight||scrollableAncestors===exports.KeyboardCode.Left&&!isLeft)&&JSCompiler_inline_result!==code.x){if(scrollableAncestors===exports.KeyboardCode.Right&&scrollContainer.scrollLeft+coordinatesDelta.x<=maxScroll.x||
scrollableAncestors===exports.KeyboardCode.Left&&scrollContainer.scrollLeft+coordinatesDelta.x>=minScroll.x){scrollContainer.scrollBy({left:coordinatesDelta.x,behavior:scrollBehavior});return}scrollDelta.x=scrollableAncestors===exports.KeyboardCode.Right?scrollContainer.scrollLeft-maxScroll.x:scrollContainer.scrollLeft-minScroll.x;scrollContainer.scrollBy({left:-scrollDelta.x,behavior:scrollBehavior});break}else if(canScrollY&&scrollElementRect!==code.y){if(scrollableAncestors===exports.KeyboardCode.Down&&
scrollContainer.scrollTop+coordinatesDelta.y<=maxScroll.y||scrollableAncestors===exports.KeyboardCode.Up&&scrollContainer.scrollTop+coordinatesDelta.y>=minScroll.y){scrollContainer.scrollBy({top:coordinatesDelta.y,behavior:scrollBehavior});return}scrollDelta.y=scrollableAncestors===exports.KeyboardCode.Down?scrollContainer.scrollTop-maxScroll.y:scrollContainer.scrollTop-minScroll.y;scrollContainer.scrollBy({top:-scrollDelta.y,behavior:scrollBehavior});break}}this.handleMove(event,utilities.add(code,
scrollDelta))}}}handleMove(event,coordinates){const {onMove}=this.props;event.preventDefault();onMove(coordinates);this.coordinates=coordinates}handleEnd(event){const {onEnd}=this.props;event.preventDefault();this.detach();onEnd()}handleCancel(event){const {onCancel}=this.props;event.preventDefault();this.detach();onCancel()}detach(){this.listeners.removeAll();this.windowListeners.removeAll()}}KeyboardSensor.activators=[{eventName:"onKeyDown",handler:(event,$jscomp$destructuring$var76)=>{var {keyboardCodes=
defaultKeyboardCodes,onActivation}=$jscomp$destructuring$var76;({code:$jscomp$destructuring$var76}=event.nativeEvent);return keyboardCodes.start.includes($jscomp$destructuring$var76)?(event.preventDefault(),null==onActivation?void 0:onActivation({event:event.nativeEvent}),!0):!1}}];class AbstractPointerSensor{constructor(props,events,listenerTarget){if(void 0===listenerTarget){listenerTarget=props.event.target;var {EventTarget}=utilities.getWindow(listenerTarget);listenerTarget=listenerTarget instanceof
EventTarget?listenerTarget:utilities.getOwnerDocument(listenerTarget)}var _getEventCoordinates;this.events=this.props=void 0;this.autoScrollEnabled=!0;this.document=void 0;this.activated=!1;this.initialCoordinates=void 0;this.timeoutId=null;this.windowListeners=this.documentListeners=this.listeners=void 0;({event:EventTarget}=props);const {target}=EventTarget;this.props=props;this.events=events;this.document=utilities.getOwnerDocument(target);this.documentListeners=new Listeners(this.document);this.listeners=
new Listeners(listenerTarget);this.windowListeners=new Listeners(utilities.getWindow(target));this.initialCoordinates=null!=(_getEventCoordinates=utilities.getEventCoordinates(EventTarget))?_getEventCoordinates:defaultCoordinates;this.handleStart=this.handleStart.bind(this);this.handleMove=this.handleMove.bind(this);this.handleEnd=this.handleEnd.bind(this);this.handleCancel=this.handleCancel.bind(this);this.handleKeydown=this.handleKeydown.bind(this);this.removeTextSelection=this.removeTextSelection.bind(this);
this.attach()}attach(){const {events,props:{options:{activationConstraint}}}=this;this.listeners.add(events.move.name,this.handleMove,{passive:!1});this.listeners.add(events.end.name,this.handleEnd);this.windowListeners.add(EventName.Resize,this.handleCancel);this.windowListeners.add(EventName.DragStart,preventDefault);this.windowListeners.add(EventName.VisibilityChange,this.handleCancel);this.windowListeners.add(EventName.ContextMenu,preventDefault);this.documentListeners.add(EventName.Keydown,this.handleKeydown);
if(activationConstraint){if(activationConstraint&&"distance"in activationConstraint)return;if(activationConstraint&&"delay"in activationConstraint){this.timeoutId=setTimeout(this.handleStart,activationConstraint.delay);return}}this.handleStart()}detach(){this.listeners.removeAll();this.windowListeners.removeAll();setTimeout(this.documentListeners.removeAll,50);null!==this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}handleStart(){const {initialCoordinates}=this,{onStart}=this.props;
initialCoordinates&&(this.activated=!0,this.documentListeners.add(EventName.Click,stopPropagation,{capture:!0}),this.removeTextSelection(),this.documentListeners.add(EventName.SelectionChange,this.removeTextSelection),onStart(initialCoordinates))}handleMove(event){var _getEventCoordinates2;const {activated,initialCoordinates,props}=this,{onMove,options:{activationConstraint}}=props;if(initialCoordinates){var coordinates=null!=(_getEventCoordinates2=utilities.getEventCoordinates(event))?_getEventCoordinates2:
defaultCoordinates;_getEventCoordinates2=utilities.subtract(initialCoordinates,coordinates);if(!activated&&activationConstraint){if(activationConstraint&&"delay"in activationConstraint){if(hasExceededDistance(_getEventCoordinates2,activationConstraint.tolerance))return this.handleCancel();return}if(activationConstraint&&"distance"in activationConstraint){if(null!=activationConstraint.tolerance&&hasExceededDistance(_getEventCoordinates2,activationConstraint.tolerance))return this.handleCancel();if(hasExceededDistance(_getEventCoordinates2,
activationConstraint.distance))return this.handleStart();return}}event.cancelable&&event.preventDefault();onMove(coordinates)}}handleEnd(){const {onEnd}=this.props;this.detach();onEnd()}handleCancel(){const {onCancel}=this.props;this.detach();onCancel()}handleKeydown(event){event.code===exports.KeyboardCode.Esc&&this.handleCancel()}removeTextSelection(){var _this$document$getSel;null==(_this$document$getSel=this.document.getSelection())?void 0:_this$document$getSel.removeAllRanges()}}const events=
{move:{name:"pointermove"},end:{name:"pointerup"}};class PointerSensor extends AbstractPointerSensor{constructor(props){var {event}=props;event=utilities.getOwnerDocument(event.target);super(props,events,event)}}PointerSensor.activators=[{eventName:"onPointerDown",handler:($jscomp$destructuring$var77,$jscomp$destructuring$var78)=>{({nativeEvent:$jscomp$destructuring$var77}=$jscomp$destructuring$var77);({onActivation:$jscomp$destructuring$var78}=$jscomp$destructuring$var78);if(!$jscomp$destructuring$var77.isPrimary||
0!==$jscomp$destructuring$var77.button)return!1;null==$jscomp$destructuring$var78?void 0:$jscomp$destructuring$var78({event:$jscomp$destructuring$var77});return!0}}];const events$1={move:{name:"mousemove"},end:{name:"mouseup"}};var MouseButton;(function(MouseButton){MouseButton[MouseButton.RightClick=2]="RightClick"})(MouseButton||(MouseButton={}));class MouseSensor extends AbstractPointerSensor{constructor(props){super(props,events$1,utilities.getOwnerDocument(props.event.target))}}MouseSensor.activators=
[{eventName:"onMouseDown",handler:($jscomp$destructuring$var79,$jscomp$destructuring$var80)=>{({nativeEvent:$jscomp$destructuring$var79}=$jscomp$destructuring$var79);({onActivation:$jscomp$destructuring$var80}=$jscomp$destructuring$var80);if($jscomp$destructuring$var79.button===MouseButton.RightClick)return!1;null==$jscomp$destructuring$var80?void 0:$jscomp$destructuring$var80({event:$jscomp$destructuring$var79});return!0}}];const events$2={move:{name:"touchmove"},end:{name:"touchend"}};class TouchSensor extends AbstractPointerSensor{constructor(props){super(props,
events$2)}static setup(){function noop(){}window.addEventListener(events$2.move.name,noop,{capture:!1,passive:!1});return function(){window.removeEventListener(events$2.move.name,noop)}}}TouchSensor.activators=[{eventName:"onTouchStart",handler:($jscomp$destructuring$var81,$jscomp$destructuring$var82)=>{({nativeEvent:$jscomp$destructuring$var81}=$jscomp$destructuring$var81);({onActivation:$jscomp$destructuring$var82}=$jscomp$destructuring$var82);const {touches}=$jscomp$destructuring$var81;if(1<touches.length)return!1;
null==$jscomp$destructuring$var82?void 0:$jscomp$destructuring$var82({event:$jscomp$destructuring$var81});return!0}}];const defaultSensors=[{sensor:PointerSensor,options:{}},{sensor:KeyboardSensor,options:{}}],defaultData={current:{}},ActiveDraggableContext=React.createContext(Object.assign({},defaultCoordinates,{scaleX:1,scaleY:1}));global=React.memo(function($jscomp$destructuring$var86){var $jscomp$destructuring$var88=Object.assign({},$jscomp$destructuring$var86),id$jscomp$0=$jscomp$destructuring$var86.id,
autoScroll=void 0===$jscomp$destructuring$var86.autoScroll?!0:$jscomp$destructuring$var86.autoScroll,announcements=$jscomp$destructuring$var86.announcements,children=$jscomp$destructuring$var86.children,sensors=void 0===$jscomp$destructuring$var86.sensors?defaultSensors:$jscomp$destructuring$var86.sensors,collisionDetection=void 0===$jscomp$destructuring$var86.collisionDetection?rectIntersection:$jscomp$destructuring$var86.collisionDetection,measuring=$jscomp$destructuring$var86.measuring,modifiers=
$jscomp$destructuring$var86.modifiers;$jscomp$destructuring$var86=void 0===$jscomp$destructuring$var86.screenReaderInstructions?screenReaderInstructions:$jscomp$destructuring$var86.screenReaderInstructions;$jscomp$destructuring$var88=(delete $jscomp$destructuring$var88.id,delete $jscomp$destructuring$var88.autoScroll,delete $jscomp$destructuring$var88.announcements,delete $jscomp$destructuring$var88.children,delete $jscomp$destructuring$var88.sensors,delete $jscomp$destructuring$var88.collisionDetection,
delete $jscomp$destructuring$var88.measuring,delete $jscomp$destructuring$var88.modifiers,delete $jscomp$destructuring$var88.screenReaderInstructions,$jscomp$destructuring$var88);var _measuring$draggable$,_measuring$draggable,_sensorContext$curren,_measuring$dragOverla,_dragOverlay$nodeRef$,_dragOverlay$rect,_over$rect;const store=React.useReducer(reducer,void 0,getInitialState),[state,dispatch]=store,[monitorState,setMonitorState]=React.useState(()=>({type:null,event:null})),[isDragging,setIsDragging]=
React.useState(!1),{draggable:{active:activeId,nodes:draggableNodes,translate},droppable:{containers:droppableContainers$jscomp$0}}=state,node$jscomp$0=activeId?draggableNodes[activeId]:null,activeRects=React.useRef({initial:null,translated:null}),active$jscomp$0=React.useMemo(()=>{var _node$data;return null!=activeId?{id:activeId,data:null!=(_node$data=null==node$jscomp$0?void 0:node$jscomp$0.data)?_node$data:defaultData,rect:activeRects}:null},[activeId,node$jscomp$0]),activeRef=React.useRef(null),
[activeSensor,setActiveSensor]=React.useState(null),[activatorEvent,setActivatorEvent]=React.useState(null),latestProps=utilities.useLatestValue($jscomp$destructuring$var88,Object.values($jscomp$destructuring$var88)),draggableDescribedById=utilities.useUniqueId("DndDescribedBy",id$jscomp$0);id$jscomp$0=React.useMemo(()=>droppableContainers$jscomp$0.getEnabled(),[droppableContainers$jscomp$0]);const {droppableRects,measureDroppableContainers,measuringScheduled}=useDroppableMeasuring(id$jscomp$0,{dragging:isDragging,
dependencies:[translate.x,translate.y],config:null==measuring?void 0:measuring.droppable}),activeNode=useCachedNode(draggableNodes,activeId);$jscomp$destructuring$var88=activatorEvent?utilities.getEventCoordinates(activatorEvent):null;const activeNodeRect=useRect(activeNode,null!=(_measuring$draggable$=null==measuring?void 0:null==(_measuring$draggable=measuring.draggable)?void 0:_measuring$draggable.measure)?_measuring$draggable$:getTransformAgnosticClientRect),containerNodeRect=useClientRect(activeNode?
activeNode.parentElement:null),sensorContext=React.useRef({active:null,activeNode,collisionRect:null,collisions:null,droppableRects,draggableNodes,draggingNode:null,draggingNodeRect:null,droppableContainers:droppableContainers$jscomp$0,over:null,scrollableAncestors:[],scrollAdjustedTranslate:null});_measuring$draggable$=droppableContainers$jscomp$0.getNodeFor(null==(_sensorContext$curren=sensorContext.current.over)?void 0:_sensorContext$curren.id);const dragOverlay=useDragOverlayMeasuring({measure:null==
measuring?void 0:null==(_measuring$dragOverla=measuring.dragOverlay)?void 0:_measuring$dragOverla.measure}),draggingNode=null!=(_dragOverlay$nodeRef$=dragOverlay.nodeRef.current)?_dragOverlay$nodeRef$:activeNode,draggingNodeRect=null!=(_dragOverlay$rect=dragOverlay.rect)?_dragOverlay$rect:activeNodeRect,initialActiveNodeRectRef=React.useRef(null);measuring=initialActiveNodeRectRef.current;measuring=draggingNodeRect===activeNodeRect?activeNodeRect&&measuring?{x:activeNodeRect.left-measuring.left,y:activeNodeRect.top-
measuring.top}:defaultCoordinates:defaultCoordinates;const windowRect=useWindowRect(draggingNode?draggingNode.ownerDocument.defaultView:null),scrollableAncestors=useScrollableAncestors(activeId?null!=_measuring$draggable$?_measuring$draggable$:draggingNode:null),scrollableAncestorRects=useClientRects(scrollableAncestors);measuring=applyModifiers(modifiers,{transform:{x:translate.x-measuring.x,y:translate.y-measuring.y,scaleX:1,scaleY:1},activatorEvent,active:active$jscomp$0,activeNodeRect,containerNodeRect,
draggingNodeRect,over:sensorContext.current.over,overlayNodeRect:dragOverlay.rect,scrollableAncestors,scrollableAncestorRects,windowRect});modifiers=$jscomp$destructuring$var88?utilities.add($jscomp$destructuring$var88,translate):null;_sensorContext$curren=useScrollOffsets(scrollableAncestors);const scrollAdjustedTranslate=utilities.add(measuring,_sensorContext$curren),collisionRect=draggingNodeRect?getAdjustedRect(draggingNodeRect,measuring):null,collisions$jscomp$0=active$jscomp$0&&collisionRect?
collisionDetection({active:active$jscomp$0,collisionRect,droppableContainers:id$jscomp$0,pointerCoordinates:modifiers}):null,overId=getFirstCollision(collisions$jscomp$0,"id"),[over$jscomp$0,setOver]=React.useState(null);collisionDetection=adjustScale(measuring,null!=(_over$rect=null==over$jscomp$0?void 0:over$jscomp$0.rect)?_over$rect:null,activeNodeRect);const instantiateSensor=React.useCallback((event$jscomp$0,$jscomp$destructuring$var89)=>{function createHandler(type){return function(){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const {active,
collisions,over,scrollAdjustedTranslate}=sensorContext.current;let event=null;if(active&&scrollAdjustedTranslate){const {cancelDrop}=latestProps.current;event={active,collisions,delta:scrollAdjustedTranslate,over};type===Action.DragEnd&&"function"===typeof cancelDrop&&(yield Promise.resolve(cancelDrop(event)))&&(type=Action.DragCancel)}activeRef.current=null;reactDom.unstable_batchedUpdates(()=>{dispatch({type});setOver(null);setIsDragging(!1);setActiveSensor(null);setActivatorEvent(null);event&&
setMonitorState({type,event});if(event){const {onDragCancel,onDragEnd}=latestProps.current,handler=type===Action.DragEnd?onDragEnd:onDragCancel;null==handler?void 0:handler(event)}})})}}var {sensor:Sensor,options}=$jscomp$destructuring$var89;if(activeRef.current&&($jscomp$destructuring$var89=draggableNodes[activeRef.current])){var sensorInstance=new Sensor({active:activeRef.current,activeNode:$jscomp$destructuring$var89,event:event$jscomp$0.nativeEvent,options,context:sensorContext,onStart(initialCoordinates){const id=
activeRef.current;if(id){var node=draggableNodes[id];if(node){var {onDragStart}=latestProps.current,event={active:{id,data:node.data,rect:activeRects}};reactDom.unstable_batchedUpdates(()=>{dispatch({type:Action.DragStart,initialCoordinates,active:id});setMonitorState({type:Action.DragStart,event})});null==onDragStart?void 0:onDragStart(event)}}},onMove(coordinates){dispatch({type:Action.DragMove,coordinates})},onEnd:createHandler(Action.DragEnd),onCancel:createHandler(Action.DragCancel)});reactDom.unstable_batchedUpdates(()=>
{setActiveSensor(sensorInstance);setActivatorEvent(event$jscomp$0.nativeEvent)})}},[draggableNodes]);_over$rect=React.useCallback((handler,sensor)=>(event,active)=>{const nativeEvent=event.nativeEvent;null!==activeRef.current||nativeEvent.dndKit||nativeEvent.defaultPrevented||!0!==handler(event,sensor.options)||(nativeEvent.dndKit={capturedBy:sensor.sensor},activeRef.current=active,instantiateSensor(event,sensor))},[instantiateSensor]);const activators=useCombineActivators(sensors,_over$rect);useSensorSetup(sensors);
React.useEffect(()=>{null!=activeId&&setIsDragging(!0)},[activeId]);React.useEffect(()=>{active$jscomp$0||(initialActiveNodeRectRef.current=null);active$jscomp$0&&activeNodeRect&&!initialActiveNodeRectRef.current&&(initialActiveNodeRectRef.current=activeNodeRect)},[activeNodeRect,active$jscomp$0]);React.useEffect(()=>{const {onDragMove}=latestProps.current,{active,collisions,over}=sensorContext.current;if(active){var event={active,collisions,delta:{x:scrollAdjustedTranslate.x,y:scrollAdjustedTranslate.y},
over};setMonitorState({type:Action.DragMove,event});null==onDragMove?void 0:onDragMove(event)}},[scrollAdjustedTranslate.x,scrollAdjustedTranslate.y]);React.useEffect(()=>{const {active,collisions,droppableContainers,scrollAdjustedTranslate}=sensorContext.current;if(active&&activeRef.current&&scrollAdjustedTranslate){var {onDragOver}=latestProps.current,overContainer=droppableContainers.get(overId),over=overContainer&&overContainer.rect.current?{id:overContainer.id,rect:overContainer.rect.current,
data:overContainer.data,disabled:overContainer.disabled}:null,event={active,collisions,delta:{x:scrollAdjustedTranslate.x,y:scrollAdjustedTranslate.y},over};reactDom.unstable_batchedUpdates(()=>{setOver(over);setMonitorState({type:Action.DragOver,event});null==onDragOver?void 0:onDragOver(event)})}},[overId]);utilities.useIsomorphicLayoutEffect(()=>{sensorContext.current={active:active$jscomp$0,activeNode,collisionRect,collisions:collisions$jscomp$0,droppableRects,draggableNodes,draggingNode,draggingNodeRect,
droppableContainers:droppableContainers$jscomp$0,over:over$jscomp$0,scrollableAncestors,scrollAdjustedTranslate};activeRects.current={initial:draggingNodeRect,translated:collisionRect}},[active$jscomp$0,activeNode,collisions$jscomp$0,collisionRect,draggableNodes,draggingNode,draggingNodeRect,droppableRects,droppableContainers$jscomp$0,over$jscomp$0,scrollableAncestors,scrollAdjustedTranslate]);useAutoScroller(Object.assign({},function(){var autoScrollGloballyDisabled="object"===typeof autoScroll?
!1===autoScroll.enabled:!1===autoScroll;autoScrollGloballyDisabled=!1!==(null==activeSensor?void 0:activeSensor.autoScrollEnabled)&&!autoScrollGloballyDisabled;return"object"===typeof autoScroll?Object.assign({},autoScroll,{enabled:autoScrollGloballyDisabled}):{enabled:autoScrollGloballyDisabled}}(),{draggingRect:collisionRect,pointerCoordinates:modifiers,scrollableAncestors,scrollableAncestorRects}));sensors=React.useMemo(()=>({active:active$jscomp$0,activeNode,activeNodeRect,activatorEvent,collisions:collisions$jscomp$0,
containerNodeRect,dragOverlay,draggableNodes,droppableContainers:droppableContainers$jscomp$0,droppableRects,over:over$jscomp$0,measureDroppableContainers,scrollableAncestors,scrollableAncestorRects,measuringScheduled,windowRect}),[active$jscomp$0,activeNode,activeNodeRect,activatorEvent,collisions$jscomp$0,containerNodeRect,dragOverlay,draggableNodes,droppableContainers$jscomp$0,droppableRects,over$jscomp$0,measureDroppableContainers,scrollableAncestors,scrollableAncestorRects,measuringScheduled,
windowRect]);_over$rect=React.useMemo(()=>({activatorEvent,activators,active:active$jscomp$0,activeNodeRect,ariaDescribedById:{draggable:draggableDescribedById},dispatch,draggableNodes,over:over$jscomp$0,measureDroppableContainers}),[activatorEvent,activators,active$jscomp$0,activeNodeRect,dispatch,draggableDescribedById,draggableNodes,over$jscomp$0,measureDroppableContainers]);return React__default.createElement(DndMonitorContext.Provider,{value:monitorState},React__default.createElement(InternalContext.Provider,
{value:_over$rect},React__default.createElement(PublicContext.Provider,{value:sensors},React__default.createElement(ActiveDraggableContext.Provider,{value:collisionDetection},children))),React__default.createElement(Accessibility,{announcements,hiddenTextDescribedById:draggableDescribedById,screenReaderInstructions:$jscomp$destructuring$var86}))});const NullContext=React.createContext(null),defaultResizeObserverConfig={timeout:25},defaultDropAnimation={duration:250,easing:"ease",dragSourceOpacity:0},
defaultTransform={x:0,y:0,scaleX:1,scaleY:1},defaultTransition=activatorEvent=>utilities.isKeyboardEvent(activatorEvent)?"transform 250ms ease":void 0;require=React__default.memo($jscomp$destructuring$var93=>{var {adjustScale=!1,children,dropAnimation=defaultDropAnimation,style:styleProp,transition=defaultTransition,modifiers,wrapperElement="div",className,zIndex=999}=$jscomp$destructuring$var93,_active$id,_attributesSnapshot$c;const {active,activeNodeRect,containerNodeRect,draggableNodes,activatorEvent,
over,dragOverlay,scrollableAncestors,scrollableAncestorRects,windowRect}=useDndContext();$jscomp$destructuring$var93=React.useContext(ActiveDraggableContext);$jscomp$destructuring$var93=applyModifiers(modifiers,{activatorEvent,active,activeNodeRect,containerNodeRect,draggingNodeRect:dragOverlay.rect,over,overlayNodeRect:dragOverlay.rect,scrollableAncestors,scrollableAncestorRects,transform:$jscomp$destructuring$var93,windowRect});const isDragging=null!==active;$jscomp$destructuring$var93=adjustScale?
$jscomp$destructuring$var93:Object.assign({},$jscomp$destructuring$var93,{scaleX:1,scaleY:1});var initialRect=utilities.useLazyMemo(previousValue=>isDragging?previousValue?previousValue:activeNodeRect?Object.assign({},activeNodeRect):null:null,[isDragging,activeNodeRect]);initialRect=initialRect?Object.assign({},{position:"fixed",width:initialRect.width,height:initialRect.height,top:initialRect.top,left:initialRect.left,zIndex,transform:utilities.CSS.Transform.toString($jscomp$destructuring$var93),
touchAction:"none",transformOrigin:adjustScale&&activatorEvent?getRelativeTransformOrigin(activatorEvent,initialRect):void 0,transition:"function"===typeof transition?transition(activatorEvent):transition},styleProp):void 0;const attributes=isDragging?{style:initialRect,children,className,transform:$jscomp$destructuring$var93}:void 0,attributesSnapshot=React.useRef(attributes);$jscomp$destructuring$var93=null!=attributes?attributes:attributesSnapshot.current;$jscomp$destructuring$var93=null!=$jscomp$destructuring$var93?
$jscomp$destructuring$var93:{};initialRect=Object.assign({},$jscomp$destructuring$var93);$jscomp$destructuring$var93=$jscomp$destructuring$var93.children;initialRect=(delete initialRect.children,delete initialRect.transform,initialRect);const prevActiveId=React.useRef(null!=(_active$id=null==active?void 0:active.id)?_active$id:null),dropAnimationComplete=useDropAnimation({animate:!(!dropAnimation||!prevActiveId.current||active),adjustScale,activeId:prevActiveId.current,draggableNodes,duration:null==
dropAnimation?void 0:dropAnimation.duration,easing:null==dropAnimation?void 0:dropAnimation.easing,dragSourceOpacity:null==dropAnimation?void 0:dropAnimation.dragSourceOpacity,node:dragOverlay.nodeRef.current,transform:null==(_attributesSnapshot$c=attributesSnapshot.current)?void 0:_attributesSnapshot$c.transform});_active$id=!(!$jscomp$destructuring$var93||!(children||dropAnimation&&!dropAnimationComplete));React.useEffect(()=>{if((null==active?void 0:active.id)!==prevActiveId.current){var _active$id2;
prevActiveId.current=null!=(_active$id2=null==active?void 0:active.id)?_active$id2:null}active&&attributesSnapshot.current!==attributes&&(attributesSnapshot.current=attributes)},[active,attributes]);React.useEffect(()=>{dropAnimationComplete&&(attributesSnapshot.current=void 0)},[dropAnimationComplete]);return _active$id?React__default.createElement(InternalContext.Provider,{value:defaultInternalContext},React__default.createElement(ActiveDraggableContext.Provider,{value:defaultTransform},React__default.createElement(wrapperElement,
Object.assign({},initialRect,{ref:dragOverlay.setRef}),$jscomp$destructuring$var93))):null});exports.DndContext=global;exports.DragOverlay=require;exports.KeyboardSensor=KeyboardSensor;exports.MouseSensor=MouseSensor;exports.PointerSensor=PointerSensor;exports.TouchSensor=TouchSensor;exports.applyModifiers=applyModifiers;exports.closestCenter=$jscomp$destructuring$var61=>{var {collisionRect,droppableContainers}=$jscomp$destructuring$var61;$jscomp$destructuring$var61=centerOfRectangle(collisionRect,
collisionRect.left,collisionRect.top);const collisions=[];for(const droppableContainer of droppableContainers){const {id,rect:{current:rect}}=droppableContainer;if(rect){const distBetween=distanceBetween(centerOfRectangle(rect),$jscomp$destructuring$var61);collisions.push({id,data:{droppableContainer,value:distBetween}})}}return collisions.sort(sortCollisionsAsc)};exports.closestCorners=$jscomp$destructuring$var62=>{var {collisionRect,droppableContainers}=$jscomp$destructuring$var62;$jscomp$destructuring$var62=
cornersOfRectangle(collisionRect);const collisions=[];for(const droppableContainer of droppableContainers){const {id,rect:{current:rect}}=droppableContainer;if(rect){const rectCorners=cornersOfRectangle(rect);var distances=$jscomp$destructuring$var62.reduce((accumulator,corner,index)=>accumulator+distanceBetween(rectCorners[index],corner),0);distances=Number((distances/4).toFixed(4));collisions.push({id,data:{droppableContainer,value:distances}})}}return collisions.sort(sortCollisionsAsc)};exports.defaultAnnouncements=
defaultAnnouncements;exports.defaultCoordinates=defaultCoordinates;exports.defaultDropAnimation=defaultDropAnimation;exports.getClientRect=getClientRect;exports.getFirstCollision=getFirstCollision;exports.getScrollableAncestors=getScrollableAncestors;exports.pointerWithin=$jscomp$destructuring$var64=>{var {droppableContainers,pointerCoordinates}=$jscomp$destructuring$var64;if(!pointerCoordinates)return[];$jscomp$destructuring$var64=[];for(const droppableContainer of droppableContainers){const {id,
rect:{current:rect}}=droppableContainer;if(rect&&isPointWithinRect(pointerCoordinates,rect)){var distances=cornersOfRectangle(rect).reduce((accumulator,corner)=>accumulator+distanceBetween(pointerCoordinates,corner),0);distances=Number((distances/4).toFixed(4));$jscomp$destructuring$var64.push({id,data:{droppableContainer,value:distances}})}}return $jscomp$destructuring$var64.sort(sortCollisionsAsc)};exports.rectIntersection=rectIntersection;exports.useDndContext=useDndContext;exports.useDndMonitor=
useDndMonitor;exports.useDraggable=function($jscomp$destructuring$var90){var {id,data,disabled=!1,attributes}=$jscomp$destructuring$var90;const key=utilities.useUniqueId("Droppable"),{activators,activatorEvent,active,activeNodeRect,ariaDescribedById,draggableNodes,over}=React.useContext(InternalContext),{role="button",roleDescription="draggable",tabIndex=0}=null!=attributes?attributes:{},isDragging=(null==active?void 0:active.id)===id;$jscomp$destructuring$var90=React.useContext(isDragging?ActiveDraggableContext:
NullContext);const [node$jscomp$0,setNodeRef]=utilities.useNodeRef(),listeners=useSyntheticListeners(activators,id),dataRef=utilities.useLatestValue(data);utilities.useIsomorphicLayoutEffect(()=>{draggableNodes[id]={id,key,node:node$jscomp$0,data:dataRef};return()=>{const node=draggableNodes[id];node&&node.key===key&&delete draggableNodes[id]}},[draggableNodes,id]);const memoizedAttributes=React.useMemo(()=>({role,tabIndex,"aria-pressed":isDragging&&"button"===role?!0:void 0,"aria-roledescription":roleDescription,
"aria-describedby":ariaDescribedById.draggable}),[role,tabIndex,isDragging,roleDescription,ariaDescribedById.draggable]);return{active,activatorEvent,activeNodeRect,attributes:memoizedAttributes,isDragging,listeners:disabled?void 0:listeners,node:node$jscomp$0,over,setNodeRef,transform:$jscomp$destructuring$var90}};exports.useDroppable=function($jscomp$destructuring$var91){var {data,disabled=!1,id,resizeObserverConfig}=$jscomp$destructuring$var91;const key=utilities.useUniqueId("Droppable"),{active,
dispatch,over,measureDroppableContainers}=React.useContext(InternalContext),resizeObserverConnected=React.useRef(!1),rect=React.useRef(null),callbackId=React.useRef(null),{disabled:resizeObserverDisabled,updateMeasurementsFor,timeout:resizeObserverTimeout}=Object.assign({},defaultResizeObserverConfig,resizeObserverConfig),ids=utilities.useLatestValue(null!=updateMeasurementsFor?updateMeasurementsFor:id);$jscomp$destructuring$var91=React.useCallback(()=>{resizeObserverConnected.current?(null!=callbackId.current&&
clearTimeout(callbackId.current),callbackId.current=setTimeout(()=>{measureDroppableContainers("string"===typeof ids.current?[ids.current]:ids.current);callbackId.current=null},resizeObserverTimeout)):resizeObserverConnected.current=!0},[resizeObserverTimeout]);const resizeObserver=useResizeObserver({onResize:$jscomp$destructuring$var91,disabled:resizeObserverDisabled||!active});$jscomp$destructuring$var91=React.useCallback((newElement,previousElement)=>{resizeObserver&&(previousElement&&(resizeObserver.unobserve(previousElement),
resizeObserverConnected.current=!1),newElement&&resizeObserver.observe(newElement))},[resizeObserver]);const [nodeRef,setNodeRef]=utilities.useNodeRef($jscomp$destructuring$var91),dataRef=utilities.useLatestValue(data);React.useEffect(()=>{resizeObserver&&nodeRef.current&&(resizeObserver.disconnect(),resizeObserverConnected.current=!1,resizeObserver.observe(nodeRef.current))},[nodeRef,resizeObserver]);utilities.useIsomorphicLayoutEffect(()=>{dispatch({type:Action.RegisterDroppable,element:{id,key,
disabled,node:nodeRef,rect,data:dataRef}});return()=>dispatch({type:Action.UnregisterDroppable,key,id})},[id]);React.useEffect(()=>{dispatch({type:Action.SetDroppableDisabled,id,key,disabled})},[disabled]);return{active,rect,isOver:(null==over?void 0:over.id)===id,node:nodeRef,over,setNodeRef}};exports.useSensor=function(sensor,options){return React.useMemo(()=>({sensor,options:null!=options?options:{}}),[sensor,options])};exports.useSensors=function(...sensors){return React.useMemo(()=>[...sensors].filter(sensor=>
null!=sensor),[...sensors])}}
//# sourceMappingURL=module$node_modules$$dnd_kit$core$dist$core_cjs_development.js.map
