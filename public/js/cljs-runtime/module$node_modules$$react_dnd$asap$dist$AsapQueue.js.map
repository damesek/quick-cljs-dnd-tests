{
"version":3,
"file":"module$node_modules$$react_dnd$asap$dist$AsapQueue.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,kDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG/GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,SAAR,CAAoB,IAAK,EAEzB,KAAIC,iBAAmBP,OAAA,CAAQ,0DAAR,CAGvB,MAAMM,UAAN,CAWEE,WAAW,CAACC,IAAD,CAAO,CAChB,MAAM,CACJ,MAAOC,CADH,CAEJC,YAFI,CAAA,CAGF,IAECD,EAAEE,CAAAA,MAAP,GACED,YAAA,EACA,CAAA,IAAKE,CAAAA,QAAL,CAAgB,CAAA,CAFlB,CAMAH,EAAA,CAAEA,CAAEE,CAAAA,MAAJ,CAAA,CAAcH,IAZE,CAelBK,WAAW,EAAG,CACZ,IAAKC,CAAAA,KAAL,CAAa,EAGb,KAAKC,CAAAA,aAAL,CAAqB,EAIrB,KAAKH,CAAAA,QAAL,CAAgB,CAAA,CAIhB,KAAKI,CAAAA,KAAL,CAAa,CAIb,KAAKC,CAAAA,QAAL,CAAgB,IAOhB;IAAKC,CAAAA,KAAL,CAAa,EAAAC,EAAM,CACjB,MAAM,CACJ,MAAOV,CADH,CAAA,CAEF,IAEJ,KAAA,CAAO,IAAKO,CAAAA,KAAZ,CAAoBP,CAAEE,CAAAA,MAAtB,CAAA,CAA8B,CAC5B,MAAMS,aAAe,IAAKJ,CAAAA,KAG1B,KAAKA,CAAAA,KAAL,EACAP,EAAA,CAAEW,YAAF,CAAgBC,CAAAA,IAAhB,EAMA,IAAI,IAAKL,CAAAA,KAAT,CAAiB,IAAKC,CAAAA,QAAtB,CAAgC,CAG9B,IAAK,IAAIK,KAAO,CAAX,CAAcC,UAAYd,CAAEE,CAAAA,MAAdY,CAAuB,IAAKP,CAAAA,KAA/C,CAAsDM,IAAtD,CAA6DC,SAA7D,CAAwED,IAAA,EAAxE,CACEb,CAAA,CAAEa,IAAF,CAAA,CAAUb,CAAA,CAAEa,IAAF,CAAS,IAAKN,CAAAA,KAAd,CAGZP,EAAEE,CAAAA,MAAF,EAAY,IAAKK,CAAAA,KACjB,KAAKA,CAAAA,KAAL,CAAa,CARiB,CAXJ,CAwB9B,IAAKA,CAAAA,KAAL,CADAP,CAAEE,CAAAA,MACF,CADW,CAEX,KAAKC,CAAAA,QAAL,CAAgB,CAAA,CA9BC,CAoCnB,KAAKY,CAAAA,oBAAL,CAA4BC,GAAAC,EAAO,CACjC,IAAKX,CAAAA,aAAcY,CAAAA,IAAnB,CAAwBF,GAAxB,CACA,KAAKG,CAAAA,iBAAL,EAFiC,CAanC,KAAKlB,CAAAA,YAAL,CAAoB,GAAIJ,gBAAiBuB,CAAAA,eAArB,EAAsC,IAAKX,CAAAA,KAA3C,CACpB,KAAKU,CAAAA,iBAAL;AAAyB,GAAItB,gBAAiBwB,CAAAA,wBAArB,EAA+C,EAAA,EAAM,CAE5E,GAAI,IAAKf,CAAAA,aAAcJ,CAAAA,MAAvB,CACE,KAAM,KAAKI,CAAAA,aAAcgB,CAAAA,KAAnB,EAAN,CAH0E,CAArD,CAzEb,CA1BhB,CAwJA9B,OAAQI,CAAAA,SAAR,CAAoBA,SAnK2F;",
"sources":["node_modules/@react-dnd/asap/dist/AsapQueue.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$react_dnd$asap$dist$AsapQueue\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsapQueue = void 0;\n\nvar _makeRequestCall = require(\"./makeRequestCall.js\");\n\n/* eslint-disable no-restricted-globals, @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unused-vars, @typescript-eslint/no-non-null-assertion */\nclass AsapQueue {\n  // Use the fastest means possible to execute a task in its own turn, with\n  // priority over other events including IO, animation, reflow, and redraw\n  // events in browsers.\n  //\n  // An exception thrown by a task will permanently interrupt the processing of\n  // subsequent tasks. The higher level `asap` function ensures that if an\n  // exception is thrown by a task, that the task queue will continue flushing as\n  // soon as possible, but if you use `rawAsap` directly, you are responsible to\n  // either ensure that no exceptions are thrown from your task, or to manually\n  // call `rawAsap.requestFlush` if an exception is thrown.\n  enqueueTask(task) {\n    const {\n      queue: q,\n      requestFlush\n    } = this;\n\n    if (!q.length) {\n      requestFlush();\n      this.flushing = true;\n    } // Equivalent to push, but avoids a function call.\n\n\n    q[q.length] = task;\n  }\n\n  constructor() {\n    this.queue = []; // We queue errors to ensure they are thrown in right order (FIFO).\n    // Array-as-queue is good enough here, since we are just dealing with exceptions.\n\n    this.pendingErrors = []; // Once a flush has been requested, no further calls to `requestFlush` are\n    // necessary until the next `flush` completes.\n    // @ts-ignore\n\n    this.flushing = false; // The position of the next task to execute in the task queue. This is\n    // preserved between calls to `flush` so that it can be resumed if\n    // a task throws an exception.\n\n    this.index = 0; // If a task schedules additional tasks recursively, the task queue can grow\n    // unbounded. To prevent memory exhaustion, the task queue will periodically\n    // truncate already-completed tasks.\n\n    this.capacity = 1024; // The flush function processes all tasks that have been scheduled with\n    // `rawAsap` unless and until one of those tasks throws an exception.\n    // If a task throws an exception, `flush` ensures that its state will remain\n    // consistent and will resume where it left off when called again.\n    // However, `flush` does not make any arrangements to be called again if an\n    // exception is thrown.\n\n    this.flush = () => {\n      const {\n        queue: q\n      } = this;\n\n      while (this.index < q.length) {\n        const currentIndex = this.index; // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n\n        this.index++;\n        q[currentIndex].call(); // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n\n        if (this.index > this.capacity) {\n          // Manually shift all values starting at the index back to the\n          // beginning of the queue.\n          for (let scan = 0, newLength = q.length - this.index; scan < newLength; scan++) {\n            q[scan] = q[scan + this.index];\n          }\n\n          q.length -= this.index;\n          this.index = 0;\n        }\n      }\n\n      q.length = 0;\n      this.index = 0;\n      this.flushing = false;\n    }; // In a web browser, exceptions are not fatal. However, to avoid\n    // slowing down the queue of pending tasks, we rethrow the error in a\n    // lower priority turn.\n\n\n    this.registerPendingError = err => {\n      this.pendingErrors.push(err);\n      this.requestErrorThrow();\n    }; // `requestFlush` requests that the high priority event queue be flushed as\n    // soon as possible.\n    // This is useful to prevent an error thrown in a task from stalling the event\n    // queue if the exception handled by Node.js\u2019s\n    // `process.on(\"uncaughtException\")` or by a domain.\n    // `requestFlush` is implemented using a strategy based on data collected from\n    // every available SauceLabs Selenium web driver worker at time of writing.\n    // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n\n    this.requestFlush = (0, _makeRequestCall.makeRequestCall)(this.flush);\n    this.requestErrorThrow = (0, _makeRequestCall.makeRequestCallFromTimer)(() => {\n      // Throw first error\n      if (this.pendingErrors.length) {\n        throw this.pendingErrors.shift();\n      }\n    });\n  }\n\n} // The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// // its existence.\n// rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\nexports.AsapQueue = AsapQueue;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","AsapQueue","_makeRequestCall","enqueueTask","task","q","requestFlush","length","flushing","constructor","queue","pendingErrors","index","capacity","flush","this.flush","currentIndex","call","scan","newLength","registerPendingError","err","this.registerPendingError","push","requestErrorThrow","makeRequestCall","makeRequestCallFromTimer","shift"]
}
