{
"version":3,
"file":"module$node_modules$react_dnd$dist$internals$wrapConnectorHooks.js",
"lineCount":4,
"mappings":"AAAAA,cAAA,CAAA,+DAAA,CAAoF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAuB5HC,QAASA,2BAA0B,CAACC,IAAD,CAAO,CACxC,MAAO,CAACC,aAAA,CAAgB,IAAjB,CAAuBC,OAAA,CAAU,IAAjC,CAAA,EAA0C,CAE/C,GAAI,CAAC,GAAIC,MAAOC,CAAAA,cAAX,EAA2BH,aAA3B,CAAL,CAKE,MAHAD,KAAA,CADaC,aACb,CAAWC,OAAX,CADaD,CAAAA,aAZjB,IAA4B,QAA5B,GAAI,MAsBcA,cAtBCI,CAAAA,IAAnB,CAKA,KAAUC,MAAJ,CAAU,sEAAV,CAAmF,uBAiBvEL,aAlBUI,CAAAA,IAAKE,CAAAA,WACwD,EAiBvEN,aAlBsCI,CAAAA,IAAKG,CAAAA,IAC4B,EADpB,eACoB,mCAAnF;AAA2J,sCAA3J,CAAN,CAqBE,MAAOC,aAAA,CAJSR,aAIT,CADKC,OAAAQ,CAAUC,IAAA,EAAQX,IAAA,CAAKW,IAAL,CAAWT,OAAX,CAAlBQ,CAAwCV,IAC7C,CAjBwC,CADT,CA8C1CS,QAASA,aAAY,CAACG,OAAD,CAAUC,MAAV,CAAkB,CACrC,MAAMC,YAAcF,OAAQF,CAAAA,GAC5B,IAAIK,UAAWC,CAAAA,SAAf,EAAiD,QAAjD,GAA0B,MAAOF,YAAjC,CAA2D,6OAA3D,CAEA,OAAKA,YAAL,CAMS,GAAIX,MAAOc,CAAAA,YAAX,EAAyBL,OAAzB;AAAkC,CACvCF,IAAKC,IAAAD,EAAQ,CAlBE,UAAnB,GAAI,MAmBSI,YAnBb,CAmBaA,WAlBX,CAkBwBH,IAlBxB,CADF,CAmBaG,WAhBPI,CAAAA,OAHN,CAmB0BP,IAnBP,WAAnB,GAAI,MAoBSE,OApBb,CAoBaA,MAnBX,CAmBmBF,IAnBnB,CADF,CAoBaE,MAjBPK,CAAAA,OAHN,CAoBqBP,IAFJ,CAD0B,CAAlC,CANT,CAES,GAAIR,MAAOc,CAAAA,YAAX,EAAyBL,OAAzB,CAAkC,CACvCF,IAAKG,MADkC,CAAlC,CAN4B,CAlEvCM,MAAOC,CAAAA,cAAP,CAAsBtB,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CuB,MAAO,CAAA,CADoC,CAA7C,CAGAvB,QAAQwB,CAAAA,kBAAR,CAuCAA,QAA2B,CAACC,KAAD,CAAQ,CACjC,MAAMC,aAAe,EACrBL,OAAOM,CAAAA,IAAP,CAAYF,KAAZ,CAAmBG,CAAAA,OAAnB,CAA2BC,GAAA,EAAO,CAChC,MAAM3B,KAAOuB,KAAA,CAAMI,GAAN,CAEb,IAAIA,GAAIC,CAAAA,QAAJ,CAAa,KAAb,CAAJ,CACEJ,YAAA,CAAaG,GAAb,CAAA,CAAoBJ,KAAA,CAAMI,GAAN,CADtB,KAEO,CACL,MAAME,YAAc9B,0BAAA,CAA2BC,IAA3B,CAEpBwB,aAAA,CAAaG,GAAb,CAAA,CAAoB,EAAA;AAAME,WAHrB,CALyB,CAAlC,CAWA,OAAOL,aAb0B,CArCnC,KAAIT,WAAanB,OAAA,CAAQ,qDAAR,CAAjB,CAEIO,OAASP,OAAA,CAAQ,iCAAR,CAV+G;",
"sources":["node_modules/react-dnd/dist/internals/wrapConnectorHooks.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_dnd$dist$internals$wrapConnectorHooks\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapConnectorHooks = wrapConnectorHooks;\n\nvar _invariant = require(\"@react-dnd/invariant\");\n\nvar _react = require(\"react\");\n\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  const displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n  return (elementOrNode = null, options = null) => {\n    // When passed a node, call the hook straight away.\n    if (!(0, _react.isValidElement)(elementOrNode)) {\n      const node = elementOrNode;\n      hook(node, options); // return the node so it can be chained (e.g. when within callback refs\n      // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\n      return node;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n\n    const element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    const ref = options ? node => hook(node, options) : hook;\n    return cloneWithRef(element, ref);\n  };\n}\n\nfunction wrapConnectorHooks(hooks) {\n  const wrappedHooks = {};\n  Object.keys(hooks).forEach(key => {\n    const hook = hooks[key]; // ref objects should be passed straight through without wrapping\n\n    if (key.endsWith('Ref')) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      const wrappedHook = wrapHookToRecognizeElement(hook);\n\n      wrappedHooks[key] = () => wrappedHook;\n    }\n  });\n  return wrappedHooks;\n}\n\nfunction setRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else {\n    ref.current = node;\n  }\n}\n\nfunction cloneWithRef(element, newRef) {\n  const previousRef = element.ref;\n  (0, _invariant.invariant)(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return (0, _react.cloneElement)(element, {\n      ref: newRef\n    });\n  } else {\n    return (0, _react.cloneElement)(element, {\n      ref: node => {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      }\n    });\n  }\n}\n};"],
"names":["shadow$provide","global","require","module","exports","wrapHookToRecognizeElement","hook","elementOrNode","options","_react","isValidElement","type","Error","displayName","name","cloneWithRef","ref","node","element","newRef","previousRef","_invariant","invariant","cloneElement","current","Object","defineProperty","value","wrapConnectorHooks","hooks","wrappedHooks","keys","forEach","key","endsWith","wrappedHook"]
}
